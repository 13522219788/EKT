# <center>EKT白皮书</center>

### 目录
<a href="#cp1">1、EKT公链简介</a><br/>
<a href="#cp2">2、多链多共识</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp21">2.1 多链模型</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp22">2.2 EKT为什么要设计多链模型</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp23">2.3 EKT要怎么实现多条链互相隔离又使用同一套地址呢</a><br/>

<h1 id="cp1">1、EKT公链简介</h1>
<p>比特币是第一代的去中心化的货币,实现了一个完整的去中心化记账的功能,但是开发者无法针对比特币开发去中心化的应用,于是就有了第二代区块链项目以太坊,以太坊是一个可编程平台,开发者可以开发出智能合约提交到以太坊的节点上,这样一来开发者就可以发布自己的去中心化应用程序,ERC20代币就是智能合约一个很好的应用，但是在以太坊上开发其他类型的应用的难度是非常大的。非常出名的加密猫就是一个在以太坊上运行的应用，但是有过程序设计经验的同学可以看出来，其实以太坊的加密猫在逻辑上是非常简单的，而且非常适合以太坊提供的键值对的数据模型，如果我们开发一个业务逻辑相对复杂的应用的话，仍然是没有什么特别好的选择。EKT 公链设计之初就是要实现可以跨公链进行转账的协议,同时提供功能更加完善的智能合约虚拟机,针对开发者开发不同类型的DAPP还会有不同的编程接口,所以开发者可以很方便在EKT上发行自己的币或者实现自己其他类型的DAPP,同时还可以很容易调用跨链操作API,这些都会体现在智能合约的内置接口上。</p>
<h1 id="cp2">2、多链多共识</h1>
<h2 id="cp21">2.1 多链模型</h2>
在EKT公链中，会存在多条并行的链，每条链上都会有一个主币（即交易费需要用的币）和很多普通币，多条链共享同一套用户地址（值得一提的是，在EKT中，用户的地址不是通过公钥计算出来的，而是通过申请得到的，用户可以更换自己的地址对应的公私钥对），不同的链可以存在不同的共识机制，默认是DPOS，开发者可以实现Consensus接口实现自己的接口部署自己的节点，另外我们后面也会加入对POW和POS共识的支持，相信这对于一些开发能力较弱的团队或者对区块链没有太多深入了解的团队上链开发DAPP是一个福音。
<h2 id="cp22">2.2 EKT为什么要设计多链模型</h2>
我们都知道在比特币中，TPS一般都是在7左右，以太坊15TPS，在一个去中心化的网络里，为了提升安全性是需要牺牲一定的性能的。相信很多开发者都听说过CAP理论，即consistency一致性、availability可用性，partition-tolerance分区容错性，在数据库系统中，关系型数据库选择了CA，NoSql选择了AP，三者不可兼得。那么在区块链中是一种什么情况呢？首先区块链是建立在一个不可信的网络节点上的，所以所有数据备份在同一时间节点上是不可能给具有相同的值的，所以在区块链上首先放弃了C，但是并不是在区块链上的数据并不是不一致的，在比特币中，为了保证大家最终的数据一致性，引入了最长链的算法，即包含区块数量更多的链是主链，所有的区块去同步最长链。由此看来区块链中，CAP三者也是不可兼得的，那么是否得到剩下的两个呢？我们都知道区块链是基于P2P网络的是一个服务，所有节点都可以提供数据，所以可用性是一致都有的，那么分区容错性通过最长链的同步算法就可以实现，所以区块链实现了AP优先和最终一致性。那么为什么一般情况下选择AP的NoSql可以达到很高的TPS而区块链不行呢？原因很简单，TPS的大小取决于一个公式：区块内Transaction的数量/区块产生的时间，也就是说，如果想要达到很高的TPS就必须要提高区块大小或者缩短区块产生的时间。我们都知道在比特币中，采用的是UTXO模型，使用Merkle树存储交易信息，所以树的深度就是log(n)，如果要增加区块大小，消耗的磁盘的速度将会非常快，因此不是一个明智的选择。而减少区块产生的时间看起来是一个比较合适的方案，但是如果降低挖矿难度的话，在节点数量非常多的情况下，最长链的算法并不能保证不同节点的最终一致性，所以在POW共识下是非常不合适的。那么如果才能提高TPS呢？相信答案现在已经很清楚了，那就是并行运行的多条链，对实时性要求比较高的采用DPOS共识或者瑞波共识，对去中心化程度要求比较高的可以使用POW共识，多条链互相隔离，就可以实现更高的TPS了，同时还满足了对不同去中心化程度的应用的需求。
<h2 id="cp23">2.3 EKT要怎么实现多条链互相隔离又使用同一套地址呢</h2>
相信这个问题是对很多开发者来说最难理解的了，因为我们上面提到过，在EKT中用户的地址不是通过公钥计算出来的，而是通过申请得到的，用户可以更换自己的地址对应的公私钥对，那么如果用户更换了自己的公私钥，其他链是如何校验用户的签名信息呢？方法有两种：一种是对安全性要求相对不那么高的方法，就是同步主链区块，使用最新区块校验用户的公钥信息，即使同步主链区块出现延迟也是没有关系的，因为用户修改自己的公私钥对并不代表自己的私钥已经被破解了，2的138次方的复杂度还是很大的，所以即使出现1-2个区块的延迟，旧签名仍是有效的。那么如果用户更新了自己的私钥在使用新私钥对消息进行签名的时候，侧链校验失败了怎么办？这时候在区块上可以使用第二种方法：RPC调用主链的校验方法，即将地址、消息和签名发给主链的多个节点，节点处理完成之后返回签名校验结果，一般情况下超过n/2+1个委托人节点签名通过即可以视为签名通过，可以证明当前用户拥有对此地址的权限。
<h2 id="cp24">2.4 开发者为何不直接fork EKT主链的代码部署自己的主链，而要在EKT上发布自己的侧链</h2>
能想到这个问题的读者相信都是有一定编码能力或者深谙编码原理的老司机了，因为发布自己的主链然后新增一些数据结构就可以完成一个去中心化应用的开发。EKT之所以有信心让大家在EKT上发布自己的侧链而不是fork代码有以下几个原因：<br/>
<h3 id="cp241">2.4.1 与EKT链上的其他链共享用户</h3>
在这个世界上，每个人都应该有且只有一个自己的id，并且是保存在区块链上的，如果大家对用户地址、签名拥有共识，我相信没有开发者会想着在给每个用户“取个名字”了。在EKT公链中，提供了两种不同安全性但都非常高效的用户机制，这是一个能让所有开发者达成共识并且受益的方式，我相信大家都会选择最好的方法。
<h3 id="cp242">2.4.2 与EKT上活跃的开发者共享开发库</h3>
EKT公链拥有很多的开发者，并且拥有非常大的开发者社区，与其自己闭门造轮子不如大家共享自己造出来的轮子，从github就可以看出来开源社区对programer's world影响有多大，在EKT社区上共享开发资源何尝不是一种共识呢？
<h3 id="cp243">2.4.3 EKT主链与侧链并没有主次之分</h3>
在EKT公链上，并没有主次之分，所有链都是公平的，除了用户公私钥只能放在主链上去处理之外，其他功能都是相同的。比如对于一个侧链的owner来说，在此侧链上的手续费是自己的主币，而不是EKT，所以在EKT上发布自己的侧链是一个非常好的选择。
<h1 id="cp3">3、跨公链</h1>
在EKT上，主链和侧链之间或者侧链和侧链之间除了资产打包转移之外是不存在所谓的“跨链”操作，同时也支持跨公链操作，总结起来就是：多链多共识，一链一主币，原生支持公链内跨链操作，支持跨公链操作。那么我先说一下EKT中的跨链资产转移。
<h2 id="cp31">3.1 EKT公链中的跨链资产转移</h2>
在EKT公链中，是不存在所谓的跨链交易的，用户A和用户B分别拥有Token T1和Token T2，T1和T2在不同的链上，我们将操作`A将拥有的T1给B`定义为Tx1，将操作`B将拥有的T2给A`定义为Tx2，这个时候Tx1是在Token T1所在的链上进行的，Tx2是在Token T2所在的链上进行的，手续费分别为两个链上的主币，都是普通的转账操作，因为上面提到过不同的链共享了同一套用户地址，所以并没有产生跨链操作，也就是说在EKT中是原生支持“跨链操作”的。<br/>
那既然EKT公链中原生支持跨链操作，跨链资产转移又是什么呢？跨链资产转移是指更改当前token打包的链，即一个token只会在一条链上进行打包，在EKT公链上的跨链资产转移可能有一下几个原因：当前网络比较拥堵（比如当前token所在的链使用的是POW共识，难度设置的过高）、想更换自己的共识协议、当前区块的交易费用过高、想自己创建一条侧链成为主币。进行跨链资产转移需要指定转移的高度和目标链，资产转移之后也就遵循新链的共识机制。
<h2 id="cp32">3.2 跨公链交易</h2>
在EKT中是支持对外的跨公链交易的，但是是需要一定的步骤的。
<h3 id="cp321">3.2.1 跨公链的用户共识</h3>
两个公链如果要进行跨链的资产交易的话，首先要对用户拥有共识，即从一个公链的一个地址转移到另一个链的地址需要双方都对对方的公链进行注册，最简单有效的方法就是`长地址`，在EKT中，存在两种地址：`内部地址`和`外部地址`，内部地址就是在EKT公链中各个链使用的地址，用于在EKT主链和侧链之间转账和其他DAPP的开发使用。同时EKT中还存在外部地址，外部地址拥有68byte，前4byte存储外部地址的公链id的长度和在其公链上内部地址的长度，后n位存储的是公链id和内部地址，中间用0x00填充。
<h3 id="cp322">3.2.2 跨公链的token共识</h3>
与用户地址相同，token的地址也是分为`内部地址`和`外部地址`，与用户地址相同，token的内部地址就是在EKT公链中各个链使用的地址，用于在EKT主链和侧链之间转账和其他DAPP的开发使用。同时EKT中Token也存在外部地址，同样拥有68byte，前4byte存储外部地址的公链id的长度和在其公链上内部token地址的长度，后n位存储的是公链id和内部地址，中间用0x00填充。
<h3 id="cp323">3.2.3 跨公链的交易共识</h3>
在EKT的跨公链操作中，对跨链协议是这样定义的：假如现在存在两条公链EKT定义为`PC1`和ETH定义为`PC2`，在`PC1`上有一个用户`user1`，地址位`address1`， 在`PC2`上拥有一个用户`user2`，在`PC1`上有一个Token定义为`T1`。如果`user1`要将自己在`PC1`上拥有的`T1`转移给`PC2`上的`user2`，那么在`PC2`上必须已经对`PC1`这条公链和`T1`进行了注册，这时就有了第一个报文：<a href="#handshake">跨链握手报文</a> ，当`PC2`对上述报文回复正确之后，`user1`才可以将自己的`T1`转移到了`PC2`。在此跨公链转账打包成功之后，`PC1`需要将交易信息和区块头信息发送给`PC2`进行校验，这就是第二个报文：<a href="#transaction">跨链交易报文</a> ，`PC2`校验之后存入自己的区块链中之后需要给`PC1`回复第三个报文：<a href="#confirm">跨链确认报文</a>，否则`PC1`会继续给`PC2`发送<a href="#transaction">跨链交易报文</a>，直到自己收到`PC2`的第三个报文：<a href="#confirm">跨链确认报文</a>。给`user1`将自己的`T1`转移到了`PC2`上之后，这些Token在`PC2`上怎么转移对于`PC1`来说是无关紧要的，因为在`PC1`上记录的是将`T1`转移到了`PC2`，而在`PC2`向`PC1`发送<a href="#confirm">跨链确认报文</a>的时候，`PC1`也是不会校验在`PC2`上每个地址持有`T1`的数量，而是校验在`PC1`链中当前的`PC2`公链id拥有的`T1`的数量。
<h3 id="cp324">3.2.4 跨公链报文协议</h3>
EKT在定义报文协议的时候为了兼容大多数公链，使用了HTTP协议作为基础的报文协议，请求和响应的Content-Type必须为application/json，请求参数和响应参数必须与规定相同。详见 [跨链报文协议](https://github.com/EducationEKT/EKT/blob/master/docs/crosschain.md)
<h4 id="cp3241">3.2.4.1跨链握手协议</h4>
    详见 [跨链报文协议](https://github.com/EducationEKT/EKT/blob/master/docs/crosschain.md)
<h4 id="cp3242">3.2.4.2跨链交易报文</h4>
    详见 [跨链报文协议](https://github.com/EducationEKT/EKT/blob/master/docs/crosschain.md)
<h4 id="cp3243">3.2.4.3跨链确认报文</h4>
    详见 [跨链报文协议](crosschain.md)
