# <center>EKT白皮书</center>
### 目录
<a href="#cp1">1、EKT公链简介</a><br/>
<a href="#cp2">2、多链多共识</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp21">2.1 多链模型的简述</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp22">2.2 多链模型设计的中心思想</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp23">2.3 实现多链隔离并通信</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp24">2.4 发布侧链代替直接fork EKT主链代码的几大理由</a><br/>
<a href="#cp3">3、跨公链</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp31">3.1 EKT公链中跨链资产转移</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp32">3.2 跨公链交易</a><br/>
<a href="#cp4">4、DAPP(无区块的DAPP设计)</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp41">4.1 Paxos</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp42">4.2 智能合约语言</a><br/>
<a href="#cp5">5、EKT公链适用人员</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp51">5.1 接触区块链较浅的传统互联网企业/开发者</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp52">5.2 对DAPP感兴趣的企业/开发者</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp53">5.3 缺乏数据和逻辑却想发行专属token的开发者/企业</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cp54">5.4	对于区块链有深入了解的开发者/企业</a><br/>


<h1 id="cp1">1、EKT公链简介</h1>
<p>比特币是第一代的去中心化货币,实现了完整的去中心化记账功能。但是，开发者无法根据比特币开发去中心化应用。所以顺势而出，出现了第二代区块链项目-以太坊。以太坊是一个可编程平台,开发者首先开发出智能合约，然后提交到以太坊的节点上。通过这样的方式，开发者就可以发布自己的去中心化应用程序,ERC20代币就是智能合约的典例。但是同样存在一定的弊端，开发者在以太坊上开发其他类型应用的难度是非常大的。非常出名的加密猫就是在以太坊上运行的应用程序，而且有过相关代码基础的开发者可以轻易看出来，以太坊的加密猫在逻辑上是非常简单的，而且非常适合以太坊提供的键值对的数据模型，但是如果开发者需要开发一个业务逻辑相对复杂的应用，依旧没有什么特别好的选择。EKT公链设计的目标就是要实现跨公链转账协议,同时提供功能更加完善的智能合约虚拟机。其次，针对开发者开发不同类型的DAPP还会有不同的程序接口,因此开发者可以便捷地在EKT上发行自己的币或实现自己其他类型的DAPP，更多的还有调用跨链操作API，这些都会体现在智能合约的内置接口上。</p>
<h1 id="cp2">2、多链多共识</h1>
<h2 id="cp21">2.1 多链模型的简述</h2>
EKT公链中存在多条并行的链，每条链上都会有一个主币（即交易费需要用的币）和很多附属币，多链共享同套用户地址（说明：在EKT公链中，用户的地址并不是通过公钥计算出来的，是通过申请得到的；用户可以选择性地更换钱包地址对应的公私钥对），不同链可以存在不同的共识机制，相同的默认共识机制是DPOS，允许开发者通过Consensus接口创建接口完成自己节点的部署。接下来公链开发团队会兼容对POW和POS共识的支持。这对于开发能力较弱的团队或对区块链没有太多深入了解的团队进行上链开发DAPP是一个福音。
<h2 id="cp22">2.2 多链模型设计的中心思想</h2>
在比特币中，TPS均值在7左右，而以太坊均值为15TPS。在去中心化网络里，为了提升安全性是需要以牺牲一定性能为代价的。很多开发者应该听说过CAP理论，即consistency（一致性）、availability（可用性）、partition-tolerance（分区容错性）。在数据库系统中，关系型数据库选择了CA，NoSql选择了AP，充分体现了这三者不可兼得。那么区块链中会是一种什么情况呢？首先，区块链建立在一个不可信的网络节点上，导致在同一时间节点上所有数据的备份是不可能具有相同值的，所以区块链首先放弃了C，但并不意味着区块链上的数据是不一致的。比如比特币为了保证大家最终数据一致，引入了最长链算法，即包含区块数量最多的链是主链，所有的区块数据同步到最长链上。由此看来区块链中，CAP三者中C不可得，那么是否可以得到剩下的两个呢？区块链是基于P2P网络的服务，所有节点均可提供数据，所以具有可用性；其次，分区容错性是通过最长链的同步算法实现的。故而区块链实现了AP优先和最终一致性。但是为什么一般情况下区块链达不到和同样选择AP的NoSql一样高的TPS呢？原因其实很简单。TPS的大小取决于一个公式：区块内Transaction的数量/区块产生的时间，可以看出，想要达到很高的TPS只能提高区块大小或者缩短区块产生的时间。比如比特币，采用的是UTXO模型，使用Merkle树存储交易信息，所以树的深度就是log(n)。如果要增加区块大小，消耗磁盘的速度将会非常快，因此不是明智之选，所以减少区块产生的时间看起来是比较合适的方案，但如果降低挖矿难度的话，在节点数量非常多的情况下，最长链的算法并不能保证不同节点的最终一致性，在POW共识下减少出块时间非常不合适的。那么如何提高TPS呢？答案就是并行运行多条链，对实时性要求比较高的采用DPOS共识，对去中心化程度要求比较高的可以使用POW共识，多条链互相隔离，就实现了更高的TPS，同时还满足了应用对去中心化程度不同的需求。
<h2 id="cp23">2.3 实现多链隔离并通信</h2>
实现多链隔离并通信对很多开发者来说可能最难理解，在上面提到过，在EKT公链中用户的地址不是通过公钥计算出来的，而是通过申请得到的，用户可以更换钱包地址对应的公私钥对。如果用户更换了自己的公私钥，其他链该如何校验用户的签名信息呢？方法有两种：第一种是对安全性要求相对不那么高的，可以同步主链区块，使用最新区块校验用户的公钥信息，即使在同步主链区块出现延迟也不影响，因为用户修改自己的公私钥对时并不代表自己的私钥被破解了，2的138次方的破解复杂度是很大的，所以即使出现1-2个区块的延迟，旧签名仍是有效的。假如用户更新了自己的私钥之后，使用新私钥对消息进行签名时，侧链校验失败了该怎么办呢？这时可以在区块上可以使用第二种方法：RPC调用主链的校验方法，即将地址、消息和签名发给主链的多个节点，节点处理完成之后返回签名校验结果，一般情况下超过（n/2+1）个委托人节点签名通过即可以视为签名通过，可以证明当前用户拥有对此地址的权限。
<h2 id="cp24">2.4 发布侧链代替直接fork EKT主链的代码的几大理由</h2>
看到这个问题的读者相信都是有一定编码能力或者深谙编译原理的，因为发布自己的主链之后可以通过新增一些数据结构就可以完成一个去中心化应用的开发。EKT有信心让大家在EKT公链上发布自己的侧链代替fork代码有以下几个原因：<br/>
<h3 id="cp241">2.4.1 与EKT公链上其他链共享用户</h3>
在世界上每个人都应该有且仅有一个自己的id，并且保存在区块链上，如果用户对钱包地址、签名拥有共识，相信没有开发者会想着再给每个用户“取名字”了。在EKT公链中，提供了两种不同安全性而且都非常高效的用户机制，是能让所有开发者达成共识并且受益的方式。
<h3 id="cp242">2.4.2 与EKT公链上活跃的开发者共享开发库</h3>
EKT公链拥有很多开发者，并且拥有非常庞大活跃的开发者社区，本着共享互利的原则，与其自己闭门造轮子，不如与大家共享改进自己造出来的轮子，这点从github上就可以看出来开源社区对programer's world的影响之大，在EKT社区上共享开发资源何尝不是一种共识呢？
<h3 id="cp243">2.4.3 EKT主链与侧链没有主次之分</h3>
在EKT公链上，并没有主次之分，所有链都是公平的，除了用户公私钥只能放在主链处理之外，其他功能都是相同的。比如对于某个侧链的owner来说，在此侧链上的手续费是自己的主币，而不是EKT，所以在EKT公链上发布自己的侧链是一个非常好的选择。
<h1 id="cp3">3、跨公链</h1>
在EKT公链上，主链与侧链之间或侧链与侧链之间除了资产打包转移之外是不存在其他的“跨链”操作，并且支持跨公链操作，总结起来就是：多链多共识，一链一主币，原生支持公链内跨链操作，支持跨公链操作。接下来先说一下EKT公链中的跨链资产转移。
<h2 id="cp31">3.1 EKT公链-跨链资产转移</h2>
在EKT公链中不存在所谓的跨链交易。用户A和用户B分别拥有Token T1和Token T2，T1和T2在不同的链上，我们将操作`A将拥有的T1给B`定义为Tx1，将操作`B将拥有的T2给A`定义为Tx2，这个时候Tx1是在Token T1所在的链上进行的，Tx2是在Token T2所在的链上进行的，手续费分别为两个链上的主币，都是普通的转账操作，因为上面提到过不同的链共享了同一套用户地址，所以并没有产生跨链操作，也就是说在EKT中是原生支持“跨链操作”的。<br/>
EKT公链原生支持跨链操作，那跨链资产转移是什么呢？跨链资产转移是指更改当前token打包的链，即一个token只会在一条链上进行打包，在EKT公链上的跨链资产转移可能有一下几个原因：当前网络比较拥堵（比如当前token所在的链使用的是POW共识，难度设置的过高）、想更换自己的共识协议、当前区块的交易费用过高、想自己创建一条侧链成为主币。进行跨链资产转移需要指定转移的高度和目标链，资产转移之后也就遵循新链的共识机制。
<h2 id="cp32">3.2 EKT公链-跨公链交易</h2>
EKT公链是支持对外的跨公链交易的，但是是需要一定操作。
<h3 id="cp321">3.2.1 跨公链的用户共识</h3>
两个公链如果要进行跨链的资产交易，首先要对用户拥有共识，即从一个公链的地址转移到另一个链的地址需要双方都对对方的公链进行注册，最简单有效的方法就是`长地址`。在EKT公链中，存在两种地址：`内部地址`和`外部地址`。内部地址就是在EKT公链中各个链使用的地址，用于在EKT主链和侧链之间转账和其他DAPP的开发使用；外部地址拥有 68 bytes，前 4 bytes存储外部地址的公链id的长度和在其公链上内部地址的长度，后n位存储的是公链id和内部地址，中间用0x00填充。
<h3 id="cp322">3.2.2 跨公链的token共识</h3>
与用户地址相同，token的地址也是分为`内部地址`和`外部地址`，token的内部地址就是在EKT公链中各个链使用的地址，用于在EKT主链和侧链之间转账和其他DAPP的开发使用。Token的在外部地址同样拥有 68 bytes，前 4 bytes存储外部地址的公链id的长度和在其公链上内部token地址的长度，后n位存储的是公链id和内部地址，中间用0x00填充。
<h3 id="cp323">3.2.3 跨公链的交易共识</h3>
EKT的跨公链操作对跨链协议是这样定义的：假如存在两条公链EKT定义为`PC1`和ETH定义为`PC2`，在`PC1`上有一个用户`user1`，地址位`address1`， 在`PC2`上拥有一个用户`user2`，在`PC1`上有一个Token定义为`T1`。如果`user1`要将自己在`PC1`上拥有的`T1`转移给`PC2`上的`user2`，那么在`PC2`上必须已经对`PC1`这条公链和`T1`进行了注册，这时就有了第一个报文：<a href="#handshake">跨链握手报文</a> ，当`PC2`对上述报文回复正确之后，`user1`才可以将自己的`T1`转移到了`PC2`。在此跨公链转账打包成功之后，`PC1`需要将交易信息和区块头信息发送给`PC2`进行校验，这就是第二个报文：<a href="#transaction">跨链交易报文</a> ，`PC2`校验之后存入自己的区块链中之后需要给`PC1`回复第三个报文：<a href="#confirm">跨链确认报文</a>，否则`PC1`会继续给`PC2`发送<a href="#transaction">跨链交易报文</a>，直到自己收到`PC2`的第三个报文：<a href="#confirm">跨链确认报文</a>。给`user1`将自己的`T1`转移到了`PC2`上之后，这些Token在`PC2`上怎么转移对于`PC1`来说是无关紧要的，因为在`PC1`上记录的是将`T1`转移到了`PC2`，而在`PC2`向`PC1`发送<a href="#transaction">跨链交易报文</a>的时候，`PC1`也是不会校验在`PC2`上每个地址持有`T1`的数量，而是校验在`PC1`链中当前的`PC2`公链id拥有的`T1`的数量。
<h3 id="cp324">3.2.4 跨公链报文协议</h3>
为了兼容大多数公链，EKT公链定义报文协议使用了HTTP协议作为基础，请求和响应的Content-Type必须为application/json，请求参数和响应参数必须与规定相同。详见 [跨链报文协议](docs/crosschain.md)
<h4 id="cp3241">3.2.4.1跨链握手协议</h4>
    详见 [跨链报文协议](docs/crosschain.md)
<h4 id="cp3242">3.2.4.2跨链交易报文</h4>
    详见 [跨链报文协议](docs/crosschain.md)
<h4 id="cp3243">3.2.4.3跨链确认报文</h4>
    详见 [跨链报文协议](docs/crosschain.md)
<h1 id="cp4">4、DAPP(无区块的DAPP设计)</h1>
EKT公链的DAPP分为DAPP服务端和DAPP客户端，DAPP服务端就是智能合约，DAPP客户端是基于JavaScript的一个框架，用户可以根据这个框架实现自己的客户端功能。<br/>
EKT公链的DAPP的优势体现在哪里呢？<br/>
1、上手轻松，原因在于EKT公链在设计智能合约之初考虑了现有智能合约的缺陷，上手难度大，与业务无关操作比较多，而且目前大部分的智能合约均基于KV进行存储，没有对上层智能合约提供可靠易用的SDK，门槛很高。
2、基于DPOS+PAXOS的智能合约共识机制，可以让DAPP开发者不必关注共识算法，专注于自己业务逻辑的开发。Paxos在跨区域（跨机房）环境下几乎不可用，EKT公链如何在智能合约的共识上加入了Paxos呢？详见 <a href="cp412">DPOS+Paxos</a>
<h2 id="cp41">4.1 Paxos</h2>
什么是Paxos？对分布式一致性的有过研究的人都会对Paxos有很深的认识，Google Chubby的作者Mike Burrows就曾说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。在Paxos中有一句话是这样的：如果各节点的初始状态一致，每个节点执行相同的操作序列，那么最后一定能得到一个一致的状态。这个结论是得到大家一致认可的。但是要想实现在各个节点执行相同的操作序列就是一个难题了。在Paxos中，有三种角色：Proposer、Acceptor和Learner。同一个进程可以扮演多个不同的角色。从宏观上看，比特币的一个区块就是一个带有顺序的操作序列的集合，挖矿过程中就是争夺Proposer角色的过程，当有一个Proposer发起一个提案之后，那么其他节点都会成为Acceptor，当大家对当前提案有了一个共识之后，所有节点都会成为Learner，去同步区块，然后争夺下一个节点的Proposer的权限。
<h3 id="cp411">4.1.1 什么是Paxos</h3>
Paxos的介绍上面已经讲解很详细了，在这里就不做过多解释了，给大家推荐一个博客，写的深入浅出。 <a href="http://www.cnblogs.com/linbingdong/p/6253479.html">分布式系列文章——Paxos算法原理与推导</a>
<h3 id="cp412">4.1.2 DPOS+Paxos？</h3>
DPOS类似“人大代表”制度，选出一定数量的节点来进行存储和计算，那么DPOS和Paxos又能擦出什么样的火花呢？引述上文：如果各节点的初始状态一致，每个节点执行相同的操作序列，那么最后一定能得到一个一致的状态。所以在智能合约中要做的就是让消息按照一定的顺序执行。在EKT公链中，有两种粒度的“锁”，第一种锁是用户的“锁”，即每个用户对于每个智能合约都存在一个nonce值，每次调用API当前nonce自增1，实现用户API的自然锁。那么如果一个用户对A节点发送的nonce值为`nonce1`的API对应的是`API1`，对B节点发送的nonce值为`nonce1`的API对应的是`API2`，类似于“双花问题”，又该如何处理呢？在EKT公链的设计中，每个节点都是Proposer，也都是Acceptor，当节点A收到一个客户端发送的消息`API1`之后，会对nonce进行判断，如果当前用户的nonce与数据库中刚好差1，那么当前节点会发起一个提案，如果其他节点同意了当前提案，则用户当前的nonce加一，这个时候节点B收到了`API2`，B判断当前的用户的nonce与当前nonce相等，则放弃当前API。所以对于用户的“双花攻击”，DPOS+Paxos是自带防御的。那么如果DAPP开发这有一个这样的功能：对外提供100个名额，先到先得，此时EKT公链中提供的第一种“用户锁”看起来就没什么用了，不过没关系，在EKT公链中提供了另一种锁：“全局时间锁”。全局时间锁是EKT公链的最大的一个创新，当Acceptor对一个提案进行签名的时候会带上当前的时间戳，当一半以上的Acceptor对一个提案进行签名之后，所有节点都需要执行这个提案，假如节点数为n，那么前（n/2+1）个同意节点的签名时间戳的平均值会被带入智能合约，实现全局时间。我们可以看出，实现了全局时间之后，很多问题都可以迎刃而解：资源竞争问题、客户端时间不可信问题、不同节点时间不同等等。
<h3 id="cp413">4.1.3 在智能合约上使用Paxos算法的优势</h3>
引述上文：如果各节点的初始状态一致，每个节点执行相同的操作序列，那么最后一定能得到一个一致的状态。根据Paxos的理论表达一个观点：在节点间延迟足够小的情况下，转账功能使用有向无环图的方式才是最优方式。在DPOS的情况下，是可以使用DAG代替区块的概念的，使用的人越多，理论上的TPS越高，但是在POW和POS的共识情况下，容易出现用户向两个网络延迟比较大的节点发送两个不同的交易，双花导致分叉，DAG的同步算法又无法足够成熟能支持最长深度优先，所以为了实现多链多共识的伟大愿景EKT在Token交易上放弃了Paxos算法和DAG模型，使用了区块概念。但是在智能合约上对于去中心化成都要求没那么高，故而EKT公链的智能合约采用了DPOS+Paxos共识，与客户端的API可以实现毫秒级确认和所有节点的数据同步，因此EKT公链的智能合约只支持DPOS+Paxos共识。
<h2 id="cp42">4.2 智能合约语言</h2>
EKT公链的新语言名叫AWM，是一个事件驱动的语言。事件分两种类型：用户事件和系统事件。用户事件是指DAPP客户端的调用，经过DPOS+Paxos的共识之后会发送一个事件到智能合约中。系统事件是指区块完成打包、某个txId处理完成或者智能合约订阅的一些其他事件。另外AWM支持面向对象，开发者可以使用面向对象的一些思想来编写代码。
<h3 id="cp421">4.2.1 语言特性</h3>
AWM拥有三个特性：<br/>
1、事件驱动。AWM是一个事件驱动的语言，也就是与一般语言（如C/C++，Java， Golang）不同，找不到main函数，所有的代码是围绕着事件去执行的。
2、面向对象。AWM是支持面向对象的，而且是一个天然模块化设计的一个语言，开发者可以把一些常用的结构体封装成一个对象，对对象封装一些方法，在事件驱动的函数里对对象的成员变量和成员方法进行调用。
3、模块化设计。在AWM中，允许把代码放在不同的package里面，鼓励用户把不同模块的代码放在不同的package中，供上层调用。
<h3 id="cp422">4.2.2 AWM VM</h3>
AWM VM是一个AWM的执行环境，很多人都在抱怨solidity的难以调试，AWM VM的到来会给大家一个惊喜，虽然在AWM中没有main的存在，但是用户可以在本地运行AWM VM，另外AWM VM还会对外提供API可以让开发者模拟事件，用户可以很轻易的使用Python、Shell或者JavaScript等语言编写测试案例，用来测试自己的智能合约是否能满足所有的测试案例，相信TDD是可以让大家极大的提高DAPP开发效率的。
<h3 id="cp423">4.2.3 原生函数</h3>
在AWM的底层是有许多基础库可以调用的，而且基础库是会不断完善的。值得一提的是原生数据库操作函数，在EKT公链中，智能合约封装在基础的磁盘操作之上，可以直接操作数据库。其次为用户提供三种方式的数据库操作：SQL、文档型（类似MongoDB）和KV型，开发者只需要导入响应的包即可完成响应的操作，相信SQL和文档数据库对大家开发速度和难度的提升是相当大的吧。
<h1 id="cp5">5、EKT公链适用人员</h1>
<h2 id="cp51">5.1 接触区块链较浅的传统互联网企业/开发者</h2>
EKT公链的模块化设计和完善的注释文档对于许多互联网开发者是非常友好的，一个传统的互联网开发者可以不管共识和P2P就可以编写自己的DAPP，还可以对EKT公链进行学习，部署自己的私有链。
<h2 id="cp52">5.2 对DAPP感兴趣的企业/开发者</h2>
AWM对于DAPP开发的支持是非常完善的，一个DAPP的开发者只需要一个小时的时间就可以动手写自己的DAPP了，另外还可以寻求EKT公链官方帮助，实现自己的DAPP。
<h2 id="cp53">5.3 缺乏数据和逻辑却想发行专属token的开发者/企业</h2>
EKT公链支持但不鼓励这种类型的应用。
<h2 id="cp54">5.4 对于区块链有深入了解的开发者/企业</h2>
这类开发者可以在EKT公链发PR，上传自己的共识或者其他模块的代码，然后可以发布自己的主链，共享EKT和其他链的用户基础，也可以发布一些自己写的库，与EKT公链团队一起完善国内最先进的公链。
